// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {Test, console2} from "forge-std/Test.sol";
import {Curta} from "../general/CurtaLocal.sol";
import {TinySig} from "./challenge/Challenge.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";

contract ExploitTest is Test {
    address playerAddr = makeAddr("player");
    Curta curta;
    TinySig puzzle;
    uint32 puzzleId = 3;

    function setUp() public {
        curta = new Curta();
        curta.setPuzzleId(puzzleId - 1);
        puzzle = new TinySig();
        curta.addPuzzle(puzzle, 0);
        vm.deal(playerAddr, 1 ether);
    }

    function test() public {
        vm.startPrank(playerAddr, playerAddr);

        Exploit exploit = new Exploit();

        string[] memory cmds = new string[](5);
        cmds[0] = "huffc";
        cmds[1] = "src/Curta/3_TinySig/Proxy.huff";
        cmds[2] = "-r";
        cmds[3] = "-c";
        cmds[4] = string.concat("ADDR=", Strings.toHexString(address(exploit)));
        bytes memory bytecode = vm.ffi(cmds);

        uint256 solution = uint256(bytes32(bytecode));
        curta.solve(puzzleId, solution);

        vm.stopPrank();
    }
}

contract Exploit {
    fallback(bytes calldata /* input */ ) external returns (bytes memory) {
        assembly {
            let ptr := mload(0x40)

            mstore(ptr, 0xbd8dced7bc30310eaf6c4532178481e51b3234d90e4da270c3dcdf5aa694ce6b) // h
            mstore(add(ptr, 0x20), 27) // v
            mstore(add(ptr, 0x40), 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63) // r

            return(ptr, 96)
        }
    }
}
